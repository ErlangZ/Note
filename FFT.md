快速傅立叶变换
==============

标签（空格分隔）： 线性代数 数字信号处理

------------------------------------------------------------------------

两个n次多项式相加的简单方法所需要的时间为$o(n)$，而相乘的简单方法所需时间为$o(n^2)$。经过快速傅立叶变换的多项式乘法可以将复杂度降低至$o(nlogn)$。

预备知识
--------

-   欧拉公式:$$e^{iu}=cos(u)+isin(u)$$define:$$w_n^k=e^{i2\pi k/n}=cos(\frac{2k\pi}{n})+isin(\frac{2k\pi}{n})$$
    *相消引理*：(看一下上式，相消引理很显然)：$$w_{dn}^{dk}=w_n^k$$
    *折半引理*：
    n&gt;0，且n为偶数。那么$(w_n^k)^2=w^k_{n/2}$折半引理有效的减小了问题的规模。

-   实数矩阵推广到复数矩阵: 矩阵$W$的元素$W_{ij} \in C^n$，
    $C^n$是复数域。定义向量的Hermatian变换为向量v的共轭转置$$\vec{a}^H = \bar{\vec{a}}^T$$Hermatian变换相当于转置运算在复数域上的推广。
-   求模$L$:
    $$\vec{v}\in R^n, L = \vec{v}^T.\vec{v}$$$$\vec{v}\in C^n, L = \vec{c}^H.\vec{c}$$
-   垂直Q $$W \in R^n, Q^T * Q = O $$ $$W \in C^n, Q^H* Q = O $$
-   酉矩阵U(Unitary Matrix)是正交矩阵在复数域上的推广$$ U^H*U = I$$
-   多项式
    在代数域F（比较典型的是实数域C）上，关于变量x的多项式定义为$$A(x)=\sum^{n-1}_{j=0}a_jx^j$$，其中a\_0,a\_1,...,a\_k为多项式的系数。所有系数都属于域F。其中多项式的最高次数k，为多项式的度。
-   多项式的两种表示方法：系数法、点值表示法
    系数法比较简单，就是我们最常见的表示法$A(x)=\sum^{n-1}_{j=0}a_jx^j$，很容易进行加法运算，可是进行乘法运算就比较困难，点值表示法则不同。我们知道一个k次多项式实际上只需要k个不同的点${(x_i,y_i)}$，就可以唯一确定k次多项式的系数$a_i$。
-   多项式插值的唯一性，可以参见《算法导论 -
    第30章》，具体思路也比较简单。就是证明$X*\vec{a}=\vec{y}$，X矩阵是可逆的（它的行列式不为0）。
    \#\# 傅立叶变换进行多项式乘法 \#\#
    对于多项式的算术运算，点值法很方便。$$A = [(x_0,y_0),(x_1,y_1)..(x_k,y_k)]$$$$B = [(x_0,y'_0),(x_1,y'_1)..(x_k,y'_k)]$$$$C = A + B$$$$D = A * B$$
    那么$$C = [(x_0,y_0+y'_0),(x_i,y_1+y'_1)...(x_k,y_k+y'_k)]$$$$D = [(x_0,y_0*y'_0),(x_i,y_1*y'_1)...(x_k,y_k*y'_k)]$$
    这就是傅立叶变换计算多项式乘法的基础：先使用点值法表示多项式，再直接对y进行相乘。

        利用FFT计算多项式乘法算法：
        1)使次数界增加一倍 （C=A*B，degree(C)=degree(A)+degree(B)）：
          通过加入n个值为0的高阶系数，把多项式A(x)和B(x)扩充为度为2n的多项式。
        2)求值：两次应用FFT计算A(x)和B(x)的点值表示。
        3)点乘：把A(x)和B(x)逐点相乘，得到2n个C点的点值表示
        4)插值：使用FFT的逆运算将C点变换回系数表示法。

    离散傅立叶变换DFT 和 快速傅立叶变换 FFT
    ---------------------------------------

    我们可以对多项式$A(x)=\sum_{j=0}^{n-1}a_jx^j$进行插值，将x用$w$进行置换，置换之后$W*\vec{a}=\vec{y}$。那么,$\vec{y}$就是系数向量$\vec{a}$的*离散傅立叶变换*。也写成$\vec{y}=DFT_n(\vec{a})$。有了预备知识中关于$w$性质的分析，我们可以知道用$w$就行替换，有很多数学性质上的好处。另外，为了便于计算，我们可以对$\vec{a}$扩展到$2^n$的长度。
    就是说，$A(x)$被等价变换为$F(w_n)$$$F(w_n)=\begin{matrix}1&1&1&...&1\\1&w_n^1&w_n^2&...&w_n^{n-1}\\...&...&...&...&...\\1&w_n^{n-1}&w_n^{2n-2}&...&w_n^{(n-1)*(n-1)}\end{matrix}$$$F(W_n)$有很多有用的性质，比如它是个酉矩阵，各列之间实际上是相互垂直的。
    我们再来重新观察FFT,
    $$A_n(x)=a_0+a_1x+a_2x^2+...+a_nx^n$$将n项$A_n(x)$分解成偶数项$A_{n/2}^{[0]}(x)$和奇数$A_{n/2}^{[1]}(x)$$$A_n(x)=A_{n/2}^{[0]}(x^2)+xA_{n/2}^{[1]}(x^2)$$
    仍然把$x=w_n^k$代入$A(x)$$$y_k=A_n(w_n^k)=A_{n/2}^{[0]}(w_{n/2}^k)+w_n^kA_{n/2}^{[1]}(w_{n/2}^k)$$
    $k < n/2$时，问题的规模就被缩小了一半，但是，问题只解决了一半。$k+n/2$可以计算剩下的一半$y_{k+n/2}$
    $$y_{k+n/2}=A_n(w_n^{k+n/2})=A^{[0]}_{n/2}(w_{n/2}^{k+n/2})+w_n^{k+n/2}A^{[1]}_{n/2}(w_{n/2}^{k+n/2})$$$$y_{k+n/2}=A^{[0]}_{n/2}(w_{n/2}^{k})-w_n^kA^{[1]}_{n/2}(w_{n/2}^{k})$$

        FFT算法：
        Input: A=a0, a1, ...,a(k-1); k=2^n
        Output: Y = y0, y1, ...,y(k-1)
        Function: FFT(A):
              n <- length of A
              if n==1 return A
              A[0] <- a0, a2, ..., a(k-2)
              A[1] <- a1, a3, ..., a(k-1)
              y[0] <- FFT(A[0])
              y[1] <- FFT(A[1])
              w_n = e^(i*2*pi/n)
              w = 1
              for k in [0...n/2-1]:
                  yk       = yk[0] + w*yk[1]
                  yk+(n/2) = yk[0] - w*yk[1]
                  w = w * w_n

    示例
    ----

    序列{1,2,3,4,5,6}的傅立叶变换

1.  为了便于计算将长度为6的序列扩充到长度为8的序列{0,0,1,2,3,4,5,6}
2.  拆分成{0,1,3,5},{0,2,4,6}两个子序列
3.  继续拆分成{0,3},{1,5},{0,6},{2,4}4个子序列
4.  这四个子序列的傅立叶变换为 {$0*w_2^0$, $-3*w_2^0$}, {$1*w_2^0$,
    $-5*w_2^0$}, {$0*w_2^0$, $-6*w_2^0$}, {$2*w_2^0$, $-4*w_2^0$}
5.  然后分别计算前两个和后两个序列的傅立叶变换：
    {$0*w_2^0+1*w_2^0*w_4^0$, $-3*w_2^0*w_4^1+(-5)*w_2^0*w_4^1$,
    $0*w_2^0-1*w_2^0*w_4^0$, $-3*w_2^0*w_4^1-(-5)*w_2^0*w_4^1$},
    {$0*w_2^0+2*w_2^0*w_4^0$, $(-6)*w_2^0+(-4)*w_2^0*w_4^1$,
    $0*w_2^0-2*w_2^0*w_4^0$, $(-6)*w_2^0-(-4)*w_2^0*w_4^1$}
6.  最后获得傅立叶变换
    {$0*w_2^0+1*w_2^0*w_4^0+0*w_2^0*w_8^0+2*w_2^0*w_4^0*w_8^0$,
    $-3*w_2^0*w_4^1+(-5)*w_2^0*w_4^1 + (-6)*w_2^0*w_8^1+(-4)*w_2^0*w_4^1*w_8^1$,
    $0*w_2^0-1*w_2^0*w_4^0+0*w_2^0*w_8^2-2*w_2^0*w_4^0*w_8^2$,
    $-3*w_2^0*w_4^1-(-5)*w_2^0*w_4^1+(-6)*w_2^0*w_8^3-(-4)*w_2^0*w_4^1*w_8^3$,
    $0*w_2^0+1*w_2^0*w_4^0-0*w_2^0*w_8^0-2*w_2^0*w_4^0*w_8^0$,
    $-3*w_2^0*w_4^1+(-5)*w_2^0*w_4^1- (-6)*w_2^0*w_8^1-(-4)*w_2^0*w_4^1*w_8^1$,
    $0*w_2^0-1*w_2^0*w_4^0-0*w_2^0*w_8^2+2*w_2^0*w_4^0*w_8^2$,
    $-3*w_2^0*w_4^1-(-5)*w_2^0*w_4^1-(-6)*w_2^0*w_8^3+(-4)*w_2^0*w_4^1*w_8^3$,
    }

